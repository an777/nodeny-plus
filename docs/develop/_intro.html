<!doctype html>
<html>
<head>
<title>Nodeny. Программирование. Вступление</title>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
<link rel='stylesheet' href='../i/nody.css' type='text/css'>
</head>
<body>

<div class='header'><a href='../index.html'><img src='../i/Logo.png'></a>Программирование. Вступление</div>

<p>Если вы взгляните на код NoDeny, то увидите, что практически любое действие затрагивает либо работу с БД либо формирование html.
Эти вещи очень критичны с точки зрения безопасности. Вам следует максимально придерживаться таких правил:</p>

<ul>

<li>
 <p>В любом sql-запросе необходимо использовать плейсхолдеры. Даже если в коде фильтруются параметры, при дальнейших модификацях кода
программист может не учесть всех нюансов и в sql попадут неотфильтрованные значения, что может привести к sql-иньекциям.
Пример использования плейсхолдеров:</p>

<div class='code'><div class='mark'>perl код</div>
<pre>
    my %p = Db-&gt;line("SELECT * FROM users WHERE name=? AND balance>?", $name, $chk_balance);
    Db-&gt;do("INSERT INTO ip_pool SET ip=INET_ATON(?), type='static'", $ip);
</pre>
</div>

<p>В исключительных случаях, например, когда в переменной находится имя поля и применить плейсхолдеры невозможно,
необходимо явно использовать фильтрацию:</p>

<div class='code'><div class='mark'>perl код</div>
<pre>
    my $f_field = Db-&gt;filtr($field);
    Db-&gt;do("UPDATE users SET $f_field='no' WHERE id=?", $id);
</pre>
</div>

<p>Для большей безопасности автор рекомендует следующие приемы:</p>

<div class='code'><div class='mark'>perl код</div>
<pre>
    $uid = int $uid;        # id клиента всегда целое число
    $amt = $amt + 0;        # денежная сумма всегда число
    # несмотря на то, что обезопасили входные данные, все равно используем плейсхолдеры
    Db-&gt;do("UPDATE users SET balance=balance+? WHERE id=?", $amt, $uid);
</pre>
</div>
</li>



<li>
<p>Не забывайте о транзакциях. Любую операцию, состоящую из серии sql оформляйте как транзакцию:</p>

<div class='code'><div class='mark'>perl код</div>
<pre>
    # Модуль Db выполнит эти запросы в одной транзакции и, если будет проблема, сделает rollback
    # В любом случае, гарантированно выполнятся либо все sql либо ни один
    Db-&gt;do_all(
        [ "INSERT INTO pays SET cash=?, mid=?", $amt, $uid ],
        [ "UPDATE users SET balance=balance+(?) WHERE id=? LIMIT 1", $amt, $uid ],
        [ "DELETE FROM request WHERE id=?", $request_id ],
    )>0 or Error('Пополнение счета не выполнено');
</pre>
</div>

<p>Если вышеприведенные запросы выполнить по-отдельности, то с небольшой вероятностью (а редкоповторимые баги
самые проблемные) можем получить ситуацию, когда после создания записи о платеже (1й sql), параллельно
администратор/модуль обработает и удалит запись-заявку на пополнения счета (3й sql). В результате можем
получить 2 пополнения счета по одной заявке. Не стоит отбрасывать вероятность дисконнекта БД между запросами,
что приведет к несхождению баланса с суммой платежей.
</p>

<p>Не пользуйтесь правилом «ничего катастрофического не случится, если один из sql не будет выполнен».
Например, скрипт меняет состояние учетной записи клиента и после этого пишет в базу событие об изменении.
Если этот последний sql не будет выполнен, то ничего некорректного не произойдет. За исключением того,
что админ будет долго вычислять ктоже хотел свести счеты с клиентом и заблокировал ему доступ,
когда у клиента был положительный баланс. Поэтому оформляйте sql в транзакции.
</p>
</li>



<li>
<p>При формировании HTML у NoDeny есть возможность использовать файлы с шаблонами, однако в основном используются
подпрограммы модуля calls.pm. Некоторые подпрограммы отличают отфильтрованные значения от неотфильтрованных
по типу данных: отфильтрованные необходимо «обрамлять» в квадратные скобки, т.е. из переменной получать
ссылку на массив:</p>

<div class='code'><div class='mark'>perl код</div>
<pre>
    # создаем объект-таблицу с css классом td_wide
    my $tbl-&gt;new( -class=&gt;'td_wide');
    $tbl-&gt;add( '*', 'll', '&lt;b>неотфильтрованное значение&lt;/b&gt;' );
    $tbl-&gt;add( '*', 'll', ['&lt;b>отфильтрованное значение&lt;/b&gt;'] );
    # выводим отрендеренную таблицу в основной поток
    Show $tbl-&gt;show;
</pre>
</div>

<p>Не забывайте фильтровать все данные, полученные от клиентов (в том числе администраторов), из БД или
любого другого источника.</p>

<p>Возможно, вы рассматривали такую ситуацию: клиент переходит по ссылке, но в адресной строке браузера меняет параметр
на невалидный. В ответ мы ему отправляем страницу, в которой пишем: «параметр имеет значение xxxx, что недопустимо».
При этом символы в xxxx не фильтруем т.к пользуемся такой логикой: нигде в явном виде этот параметр клиентом не вводится,
а формируется скриптом и помещается в ссылку. Значит клиент сам себе «злобный Буратино» и если ввел теги в параметр,
то пусть их и получит, экспериментатор. Однако мы забыли один важный момент: url мог быть передан клиенту
злоумышленником, и в качестве xxxx тег &lt;script&gt;...</p>

</li>

</ul>


</body>
</html>
