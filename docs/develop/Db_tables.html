<!doctype html>
<html>
<head>
<title>Nodeny. Таблицы БД</title>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
<link rel='stylesheet' href='../i/nody.css' type='text/css'>
</head>
<body>

<div class='header'><a href='../index.html'><img src='../i/Logo.png'></a>Таблицы БД</div>


<ul>
<li><a href='#admin'>admin</a></li>
<li><a href='#auth_log'>auth_log</a></li>
<li><a href='#auth_now'>auth_now</a></li>
<li><a href='#cards'>cards</a></li>
<li><a href='#changes'>changes</a></li>
<li><a href='#ip_pool'>ip_pool</a></li>
<li><a href='#pays'>pays</a></li>
<li><a href='#services'>services</a></li>
<li><a href='#traflost'>traflost</a></li>
<li><a href='#users'>users</a></li>
<li><a href='#users_services'>users_services</a></li>
<li><a href='#v_auth_now'>v_auth_now</a></li>
<li><a href='#v_ips'>v_ips</a></li>
<li><a href='#websessions'>websessions</a></li>
<li><a href='#webses_data'>webses_data</a></li>
<li><a href='#Z'>Z-таблицы</a></li>
</ul>

<br><br>


<div class='mess'><div class='mark'><a name='admin'>admin</a> - таблица администраторов</div>

<pre>
 id         : id администратора
 login      : логин администратора
 passwd     : зашифрованный пароль
 name       : имя
 post       : должность
 privil     : через запятую привилегии
 usr_grps   : через запятую id групп клиентов, к которым есть доступ
 tunes      : настройки (пока не используется)
 ext        : расширение аватара (пока не используется)
</pre>

<p>Привилегии задаются в виде списка чисел, разделенных запятыми. Каждое число указывает на то,
что соответствующая ему привилегия включена. Список соответствий число=привилегия можно узнать
из файла RU_admin.pl.</p>

<p>Список привилегий и групп клиентов начинается и заканчивается запятыми, это сделано для упрощения
sql запросов, например, <em>SELECT admin WHERE privil LIKE '%,1,%'</em> не выдал бы админов, у которых
привилегия с номером 1 была бы самой первой, т.е. без запятой перед ней.</p>
</div>

<br><br>

<div class='mess'><div class='mark'><a name='auth_now'>auth_now</a> - таблица текущих авторизаций</div>

<p>Структура:</p>

<pre>
 id         : автоинкрементное поле
 ip         : ip клиента (в текстовом виде)
 start      : timestamp начала авторизации
 last       : timestamp последнего подтверждения авторизации
 properties : дополнительные параметры
</pre>

<p>Модули авторизации устанавливают начало авторизации в start, после чего с каждым подтвержденным запросом
авторизации модифицируют поле last текущим временем. Ядро NoDeny удаляет записи, у которых last не
модифицировалось в последние xx секунд, т.е. удаляет записи `по таймауту`.</p>

<p>properties хранит параметры авторизации, разделенные `;`. Обязательный параметр mod - модуль, которым
была осуществлена авторизация.</p>
</div>
<br><br>




<div class='mess'><div class='mark'><a name='auth_log'>auth_log</a> - лог авторизаций</div>

<p>Структура:</p>

<pre>
 id         : автоинкрементное поле
 uid        : id клиента
 ip         : ip клиента (unsigned int)
 start      : начало сессии (timestamp)
 end        : конец сессии (timestamp)
 properties : дополнительные параметры
</pre>

<p>Когда клиент перестает быть авторизованным, ядро удаляет запись из таблицы auth_now и создает запись
в auth_log, при этом параметр properties копируется из auth_now в auth_log</p>
</div>
<br><br>



<div class='mess'><div class='mark'><a name='ip_pool'>ip_pool</a> - пул ip адресов</div>

<pre>
 id         : уникальный id записи
 ip         : ip (unsigned int)
 type       : тип ip (статический, динамический, зарезервирован)
 realip     : флаг «реальный ip»
 release    : timestamp освобождения, если ip динамический
 uid        : id клиента
</pre>

<p>Если ip не привязан ни к какому клиенту, то uid = 0. Если ip статический, то он привязывается клиенту
навсегда, вернее, до того момента, пока администратор не отвяжет его.</p>

<p>Динамический ip привязывается клиенту во время первой авторизации, после чего устанавливается поле
release на пару минут в будущее. Каждое обновление авторизации отодвигает release в будущее. По
окончанию авторизации, когда release станет большим текущего времени, поле uid устанавливается в 0.</p>

</div>
<br><br>



<div class='mess'><div class='mark'><a name='pays'>pays</a> - таблица платежей и событий</div>

<pre>
 id         : уникальный id записи
 mid        : id клиента (см. таблицу users)
 cash       : денежная сумма, для всех нефинансовых записей = 0
 time       : timestamp формирования записи
 creator    : автор записи (админ/клиент/ядро)
 creator_id : id автора записи
 creator_ip : ip автора записи, для ядра = 0, что соответствует 0.0.0.0
 reason     : многофункциональное поле, хранит закодированные детали платежа/события
 coment     : обычно сообщение для клиента
 category   : категория платежа, более детально сообщает о внутреннем устройстве
              текущей записи.
</pre>

<p>Pay.pm по значению category декодирует поле reason.</p>

</div>
<br><br>




<div class='mess'><div class='mark'><a name='services'>services</a></div>

<p>Структура:</p>

<pre>
    service_id  : id услуги
    module      : модуль, который обрабатывает услугу
    category    : краткое описание модуля услуги
    title       : название услуги
    description : описание услуги
    grp_list    : через запятую группы клиентов, которые могут заказать услугу
    price       : стоимость услуги
    auto_renew  : автопродление услуги
    no_renew    : блокировка автопродления
    param       : дополнительные параметры
</pre>

<p>В таблице services описываются услуги, предоставляемые разными модулями.</p>

<p>Поле module хранит имя файла модуля без расширения pm в каталоге /usr/local/nodeny/services/.</p>

<p>Список групп в grp_list начинается и заканчивается запятыми для упрощения sql запросов.</p>

</div>
<br><br>



<div class='mess'><div class='mark'><a name='traflost'>traflost</a> - таблица неучтенного трафика</div>
<p>traflost хранит данные о трафике, который не удалось классифицировать, что свидетельствует о
неправильной настройке системы, например, пробросе трафика вне контроля NoDeny либо неправильной
настройке NoDeny.</p>

<pre>
 time       : время среза в timestamp
 traf       : количество байт
 collector  : номер коллектора каким он указан в настройках
 ip1        : ip источника
 ip2        : ip приемника
</pre>

</div>
<br><br>




<div class='mess'><div class='mark'><a name='users'>users</a> - таблица с основными данными клиентов</div>

<pre>
 id             : id учетной записи клиента
 name           : (теперь) логин/учетное имя
 passwd         : зашифрованный пароль
 grp            : группа (см. табл. user_grp)
 contract       : договор
 contract_date  : timestamp заключения договора
 state          : состояние доступа вкл/выкл
 balance        : баланс
 limit_balance  : граница отключения
 block_if_limit : отключать ли запись при достижении границы отключения
 modify_time    : timestamp последней модификации записи
 fio            : ФИО
 cstate         : техническое состояние (настроить/ремонт/вирусы...)
 cstate_time    : timestamp последнего изменения поля cstate
 comment        : комментарий
 lstate         : нужна авторизация/всегда онлайн;
</pre>

</div>
<br><br>



<div class='mess'><div class='mark'><a name='users_services'>users_services</a> -
подключенные клиентам услуги</div>

<p>Структура:</p>

<pre>
 id         : уникальный id записи
 uid        : id учетной записи клиента
 pay_id     : id платежа в таблице pays
 service_id : ссылка на id услуги в таблице services
 tm_start   : timestamp подключения услуги
 tm_end     : timestamp, когда услуга должна завершиться
 next_service_id : после завершения услуги подключится эта услуга
 tags       : теги
</pre>

<p>В таблице services описываются услуги в общем виде, в таблице users_services конкретно
привязываются к клиентам.</p>

<p>Если услуга не создает запись в таблице платежей, то pay_id = 0.</p>

<p>После окончания действия услуги, запись удаляется и если поле next_service_id не равно 0,
то создается новая запись, в которой поле service_id устанавливается равным next_service_id.</p>

<p>Теги - перечисленные через запятую ключевые слова, характеристики услуги. Например, слово inet
сообщает, что услуга должна давать доступ в интернет. Модуль управления фаерволом сканирует услуги
на наличие этого слова.</p>

</div>
<br><br>



<div class='mess'><div class='mark'><a name='v_auth_now'>v_auth_now</a> - некоторые данные клиентов,
авторизованных в данный момент</div>

<p>Структура:</p>

<pre>
    ip          : ip в текстовом виде
    id          : id клиента
    balance     : баланс
    state       : 'off' - доступ заблокирован, 'on' - включен
    limit_money : граница отключения
    in1..in3    : входящий трафик
    out1..out4  : исходящий трафик
</pre>

<p>Если клиент не блокируется по лимиту (поле block_if_limit таблицы users не установлено), то
limit_money в этой view = -9999.</p>
</div>
<br><br>



<div class='mess'><div class='mark'><a name='v_ips'>v_ips</a> - список ip, привязанных к клиентам в данный момент</div>

<p>Структура:</p>

<pre>
    uid         : id клиента
    ip          : ip в текстовом виде
    ipn         : ip в unsigned int
    type        : тип ip (статический/динамический)
    release     : timestamp освобождения ip, если он динамический
    tm_auth     : длительность авторизации, секунд
    start       : timestamp начала авторизации
    last        : timestamp последнего подтверждения авторизации
    properties  : параметры авторизации
    auth        : 1 - авторизован, 0 - нет
</pre>

<p>Данная view - это объединение таблиц ip_pool и auth_now. Содержит список всех ip, которые
выделены клиентам. Если в данный момент ip не авторизован, то tm_auth, start, last и properties
равны NULL.</p>

</div>
<br><br>




<div class='mess'><div class='mark'><a name='websessions'>websessions</a></div>

<p>Структура:</p>

<pre>
    ses     : сессия
    uid     : id клиента либо администратора
    role    : владелец сесии администратор или клиент
    trust   : 0 - безопасная сессия
    expire  : timestamp времени удаления записи
</pre>

<p>По умолчанию trust=1, что дает право админу выполнять любые действия. Админ может установить
поле в 0, если работает не за доверенным компьютером, поэтому в случае если он отлучится от
админки, никто не сможет навредить, поскольку важные действия будут заблокированы.</p>

</div>
<br><br>




<div class='mess'><div class='mark'><a name='webses_data'>webses_data</a></div>
<p>Таблица предназначена для передачи данных не через адресную строку браузера, а через базу
данных по ключу. Плюсы:<p>

<ul>
<li>Сокращает объем передаваемых данных через адресную строку. Например, на странице поиска
клиентов был применен фильтр и найдено несколько сотен записей, удовлетворяющих условию. Необходимо
отобразить найденных клиентов на карте. Если передавать список в адресной строке, то можно
выйти за лимиты размера адресной строки. В случае использования таблицы webses_data, передается
короткий ключ.
</li>

<li>В ситуации предыдущего примера, удобно передавать короткую ссылку иному администратору, чтобы
он увидел клиентов по фильтру.
</li>

<li>Допустим, клиент заполнил форму и отослал на сервер. При этом допустил ошибку. Посланные данные
будут записаны в webses_data. При возврате на перезаполнение формы, модуль может заполнить форму по
ранее введенным данным, т.е. клиенту не требуется заново их вводить.
</li>

<li>Безопасность. Доверенный канал передачи данных. В случае же адресной строки, данные можно подделать.
</li>
</ul>

<p>Наглядный пример в админке NoDeny: после сохранения данных, идет редирект, в параметре _unikey
ссылка на блок данных, в котором сообщение «Изменения сохранены».</p>

<p>Структура:</p>

<pre class='code'>
    role    : кто создал запись (admin/user)
    aid     : id админа/юзера, создавшего запись
    unikey  : уникальный ключ данных
    module  : модуль для, которого предназначены данные
    data    : данные
    created : timestamp времени создания записи
    expire  : timestamp времени удаления записи
</pre>

<p>Уникальный ключ генерирует calls.pm когда создает запись. По этому ключу идет выборка
данных модулем, для которого они предназначаются. Данные оформляются в виде perl-дампа, который создается
<em>Debug-&gt;dump($ref);</em><p>

<p>Формат данных может выбираться в каждом случае свой. Есть ситуация, когда он строго оговорен - это
когда ключ unikey передается браузером в параметре _unikey. В этом случае админка берет данные 
не только из адресной строки, но и из ключа `-F` хеша расшифрованного дампа в поле data.<p>

<p>calls.pm следит за тем, чтобы данные были получены только тем модулем, для которого были созданы.
В противном случае, была бы возможность подсунуть некорректные данные иному модулю.<p>

<p>В особых случаях, модуль должен проверять id администратора, если запрещено передавать текущие данные
иному.<p>

</div>
<br><br>



<div class='mess'><div class='mark'><a name='cards'>cards</a> - таблица карточек пополнения счета</div>

<p>Структура:</p>

<pre class='code'>
cid          : серийный номер карты
cod          : код активации
money        : номинал
tm_create    : время генерации карты
tm_end       : время окончания действия
tm_activate  : время активации
adm_create   : id админа, сгенерировавшего карту
alive        : состоянии карты
uid_activate : id клиента, активировавшего карту
adm_owner    : id администратора владельца карты
adm_move     : id администратора, на которого идет перемещение карты
</pre>

<p>Время активации tm_activate не равное нулю не гарантирует, что карта активирована.
Следует читать так: если карта активирована, то tm_activate указывает на время ее активации.</p>

<p>Состояние карты определяется полем alive, которое может принимать значения:</p>
<pre class='code'>
good      : карта не активирована;
bad       : карта заблокирована;
stock     : карта на складе;
activated : активирована.
</pre>

<p>Карту можно активировать только в состоянии «good». Состояние «stock» (на складе) указывает на то,
что карта пока еще не вошла в обращение. При генерации карт, им всем выставляется статус «на складе»,
что является элементом безопасности:
предполагается, что администратор производит генерацию большого числа карт и все они отправляются в печать.
При этом в реализацию они поступают партиями. Если будет замечена активация карты, которая числится на складе - 
это может свидетельствовать о том, что произошла утечка кодов пополнений.</p>

<p>В админке администратор может изменить состояние карт на любое при условии, что владельцем является он
(поле adm_owner) и карта не находится в состоянии activated.</p>

<p>Поле adm_owner указывает на администратора, который последним физически получил карту пополнения в руки.
NoDeny считает, что adm_owner владеет деньгами на сумму, равную номиналу карты. В самом деле, adm_owner либо
физически хранит у себя карту пополнения, либо продал ее клиенту и получил за это деньги.</p>

<p>adm_move указывает на администратора, на которого adm_owner желает передать карту. При этом владельцем
карты все равно является adm_owner. При подтверждении передачи, adm_move устанавливается в 0, а adm_owner -
в id администратора, принявшему карту.</p>

<p>При отказе приема карты, NoDeny устанавливает поля так, как будто получатель отправляет их назад
отправителю.</p>

</div>
<br><br>


<div class='mess'><div class='mark'><a name='Z'>Z</a> - таблицы</div>
<p>Таблицы, начинающиеся с Z, хранят детализированную статистику трафика:</p>

<pre>
 uid        : id клиента
 time       : время среза в timestamp
 bytes      : количество байт
 direction  : направление трафика, 1 - к клиенту, 0 - от клиента
 class      : номер типа трафика (локальный/интернет/...)
 uip        : ip клиента (unsigned int)
 ip         : ip удаленной стороны (unsigned int)
 port       : порт удаленной стороны
 proto      : протокол
</pre>

<p>Поле uip хранит ip клиента в момент среза, т.е. если впоследствии у клиента будет иной, сохраняется
возможность узнать какой был на момент среза.</p>
</div>
<br><br>

</body>
</html>
